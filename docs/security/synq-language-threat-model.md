# SynQ Language Threat Model

Date: 2026-02-16  
Scope: `/Users/devpup/Desktop/Synergy/synergy-components/synq-language/compiler`, `/Users/devpup/Desktop/Synergy/synergy-components/synq-language/vm`, `/Users/devpup/Desktop/Synergy/synergy-components/synq-language/cli`

## 1. Scope and System Model

In-scope runtime path:

1. SynQ source input -> parser (`compiler/src/synq.pest`, `compiler/src/parser.rs`)
2. AST -> semantic validation (`compiler/src/semantic.rs`)
3. AST -> bytecode/solidity lowering (`compiler/src/codegen.rs`, `compiler/src/solidity_gen.rs`)
4. Bytecode execution (`vm/src/vm.rs`)
5. Deterministic verification and artifact emission (`cli/src/main.rs`)

Out-of-scope:

- SDK transport/RPC security controls
- Off-chain key custody and signer infrastructure
- External deployment platform trust

## 2. Trust Boundaries

1. User-supplied contract source -> compiler front-end
2. AST -> code generation backend
3. Generated bytecode -> VM execution engine
4. PQ opcode handlers -> cryptographic FFI boundaries

## 3. Security-Critical Assets

1. Deterministic source-to-bytecode integrity
2. Semantic correctness of compiled contracts
3. VM execution integrity and safety
4. PQ verification correctness (ML-DSA/FN-DSA/ML-KEM/HQC paths)
5. Audit artifact integrity (`.compiled.synq`, `.sol`, verification outputs)

## 4. Attacker Model

Assumed realistic attacker capabilities:

- Can submit malicious SynQ source code to compiler
- Can craft malformed or adversarial bytecode inputs for VM
- Can attempt semantic confusion through parser edge-cases
- Can attempt replay/tamper workflows around bytecode artifacts

Not assumed in this model:

- Host-level compromise of build machine
- Compiler binary supply-chain compromise

## 5. Top Threats and Current Posture

### T1. Parser ambiguity / AST confusion

Threat: attacker crafts syntax that parses but lowers unexpectedly.  
Impact: incorrect contract semantics, potential authorization logic drift.  
Likelihood: Medium. Impact: High. Priority: High.

Current controls:

- Expanded grammar coverage for real contract syntax
- Integration tests for parser + codegen + VM fixture flow

Gaps:

- Source-span-rich diagnostics and strict conformance corpus still incomplete

### T2. Semantic validation bypass (undefined symbols / invalid returns)

Threat: unsafe contracts compile despite unresolved symbols or invalid return behavior.  
Impact: runtime faults or silent semantic corruption.  
Likelihood: Medium. Impact: High. Priority: High.

Current controls:

- New semantic analyzer pass in compile path
- Rejection of duplicate state declarations and duplicate parameters
- Rejection of assignment/reference to undefined symbols
- Return-value contract checks (void vs non-void)
- Baseline type checks for local initialization/assignment/returns and boolean condition enforcement
- PQC built-in signature checks for ML-DSA/FN-DSA/KEM decapsulation call sites
- Compile-time rejection of de-scoped SLH built-ins
- Flow-sensitive control-flow checks for non-void missing-return paths and unreachable statements

Gaps:

- Full lvalue-aware assignment typing awaits richer assignment AST
- Variant-level PQC policy enforcement (e.g., project-level algorithm profile constraints) remains partial

### T3. Non-deterministic or tampered build artifacts

Threat: mismatched bytecode accepted as valid output for a source contract.  
Impact: supply-chain integrity failure, audit drift.  
Likelihood: Low-Medium. Impact: High. Priority: High.

Current controls:

- `cli verify --source --bytecode` SHA-256 based deterministic comparison
- Integration tests for mismatch rejection

Gaps:

- No signed build attestation pipeline yet

### T4. VM runtime misuse and malformed bytecode abuse

Threat: crafted bytecode triggers incorrect VM state transitions or unsafe runtime behavior.  
Impact: runtime crashes/undefined execution, integrity/availability risk.  
Likelihood: Medium. Impact: High. Priority: High.

Current controls:

- Header validation, bounds checks, invalid opcode handling
- Gas and PQ gas metering

Gaps:

- More exhaustive adversarial bytecode fuzzing still required

### T5. PQ opcode misuse in contract logic

Threat: contract compiles and runs while cryptographic authorization is semantically weak (replay, intent confusion).  
Impact: authorization bypass in deployed contracts.  
Likelihood: Medium. Impact: Critical. Priority: Critical.

Current controls:

- PQ primitives integrated and exercised in fixture tests
- Foundation-level replay/compliance coverage in `aegis-pqsynq`

Gaps:

- Language-level semantic enforcement for signed intent/nonce discipline is not yet encoded

## 6. Security Work Completed in This Phase

1. Added semantic analysis stage to CLI compile pipeline (fail closed on semantic errors).
2. Added compiler semantic test suite for critical invariants.
3. Added compile-time type checks for variable initialization, assignments, returns, and boolean guards.
4. Added compile-time PQC builtin checks (ML-DSA/FN-DSA/KEM signatures) and SLH de-scope rejection.
5. Added flow-sensitive missing-return and unreachable-statement diagnostics.
6. Added parser hardening so fallback call arguments are preserved for semantic arity/type validation.
7. Added CLI regression test that compiles all six documented example contracts.
8. Maintained deterministic verify path and compile artifact integrity checks.

## 7. Priority Mitigation Backlog

1. Complete flow-sensitive semantic checks (missing-return paths, unreachable-code diagnostics).
2. Add full lvalue-aware typing (`mapping[index]`, member assignments) once assignment AST is expanded.
3. Add parser/VM fuzzing harness for adversarial syntax and bytecode inputs.
4. Add source-span-aware semantic diagnostics to improve secure triage quality.
5. Define language-level nonce/intent verification pattern and static lint for PQ auth paths.

## 8. Open Assumptions to Confirm

1. SynQ compiler/CLI execution will run in trusted CI/build agents only.
2. Deterministic build output is a required security gate before deployment.
3. PQ authorization policies (nonce/domain-separation) will be enforced as language/compiler rules, not only style guidance.
