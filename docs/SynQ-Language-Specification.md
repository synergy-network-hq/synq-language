# SynQ Language Specification

## 1. Introduction

SynQ is a novel smart contract language designed to operate securely in a post-quantum cryptographic era. It integrates first-class support for quantum-resistant cryptographic primitives, specifically focusing on the NIST-standardized ML-DSA (Module-Lattice-Based Digital Signature Algorithm), FN-DSA (FFT over NTRU-Lattice-Based Digital Signature Algorithm), ML-KEM (Module-Lattice-Based Key-Encapsulation Mechanism), and SLH-DSA (Stateless Hash-Based Digital Signature Algorithm) algorithms. This specification outlines the core components of SynQ, including its data types, built-in functions, and a resource-aware gas model tailored for the computational demands of post-quantum cryptography.

## 2. Data Types

SynQ introduces specialized data types to natively handle post-quantum cryptographic keys and signatures. These types are designed to be efficient and secure, reflecting the unique characteristics of PQC algorithms.

### 2.1. Post-Quantum Public Keys

Public keys for ML-DSA, FN-DSA, ML-KEM, and SLH-DSA are represented by distinct types, allowing for strong type checking and ensuring compatibility with their respective signature and key encapsulation mechanisms.

*   `MLDSAPublicKey`: Represents a public key for the ML-DSA digital signature scheme.
*   `FNDSAPublicKey`: Represents a public key for the FN-DSA digital signature scheme.
*   `MLKEMPublicKey`: Represents a public key for the ML-KEM Key Encapsulation Mechanism (KEM).
*   `SLHDSAPublicKey`: Represents a public key for the SLH-DSA digital signature scheme.

### 2.2. Post-Quantum Signatures

Signatures generated by ML-DSA, FN-DSA, and SLH-DSA algorithms have their own dedicated types.

*   `MLDSASignature`: Represents a digital signature generated using the ML-DSA scheme.
*   `FNDSASignature`: Represents a digital signature generated using the FN-DSA scheme.
*   `SLHDSASignature`: Represents a digital signature generated using the SLH-DSA scheme.

### 2.3. Other Primitive Types

In addition to PQC-specific types, SynQ supports standard primitive types common in smart contract languages:

**Integer Types:**
- `UInt8`, `UInt32`, `UInt64`, `UInt128`, `UInt256` - Unsigned integers of various sizes
- `Int8`, `Int32`, `Int64`, `Int128`, `Int256` - Signed integers of various sizes

**Other Types:**
- `Address` - 20-byte address type
- `Bool` - Boolean type (true/false)
- `Bytes` - Variable-length byte array
- `String` - UTF-8 string type



## 3. Built-in Functions

SynQ provides built-in functions for verifying post-quantum signatures, ensuring that cryptographic operations are performed correctly and efficiently within the smart contract environment. These functions are optimized for the underlying PQC algorithms.

### 3.1. Signature Verification

*   `verifyMLDSASignature(publicKey: MLDSAPublicKey, message: Bytes, signature: MLDSASignature): Bool`
    *   Verifies an ML-DSA signature against a message and public key. Returns `true` if the signature is valid, `false` otherwise.

*   `verifyFNDSASignature(publicKey: FNDSAPublicKey, message: Bytes, signature: FNDSASignature): Bool`
    *   Verifies an FN-DSA signature against a message and public key. Returns `true` if the signature is valid, `false` otherwise.

*   `verifySLHDSASignature(publicKey: SLHDSAPublicKey, message: Bytes, signature: SLHDSASignature): Bool`
    *   Verifies an SLH-DSA signature against a message and public key. Returns `true` if the signature is valid, `false` otherwise.

### 3.2. Key Encapsulation (ML-KEM)

While ML-KEM is a Key Encapsulation Mechanism (KEM) and not a signature scheme, its inclusion as a first-class type enables secure key exchange within the SynQ ecosystem. The VM supports ML-KEM decapsulation operations on-chain via the `mlkemDecapsulate` built-in function. Encapsulation is typically performed off-chain, with the resulting ciphertext and shared secret used on-chain for secure key exchange.

## 4. Resource and Gas Model

The computational complexity of post-quantum cryptographic operations is significantly higher than traditional cryptographic algorithms like ECDSA. SynQ's gas model is designed to accurately reflect these costs, preventing denial-of-service attacks and ensuring fair resource allocation.

### 4.1. Dynamic Gas Pricing for PQC Operations

Unlike fixed gas costs for basic operations, PQC operations have dynamic gas pricing based on the computational resources consumed. This includes factors such as:

*   **Key Size:** Larger key sizes (e.g., ML-DSA-87 vs. ML-DSA-44) will incur higher gas costs.
*   **Signature Size:** The size of the signature directly impacts the verification cost.
*   **Algorithm Complexity:** Different PQC algorithms have varying computational complexities, which are reflected in their gas costs (see Gas Model documentation for specific values).

### 4.2. Gas Cost Components

The gas cost for PQC operations is composed of:

*   **Base Cost:** A fixed cost for initiating the PQC operation (currently 4,000-7,000 gas depending on algorithm).
*   **Data Processing Cost:** A cost proportional to the size of the public key, message, and signature (approximately 6-9 gas per byte).
*   **Computational Cost:** A cost reflecting the actual CPU cycles and memory usage required for the cryptographic computation (currently 10,000-30,000 gas depending on algorithm and security level).

This detailed gas model ensures that the network remains secure and economically viable even with the integration of computationally intensive PQC algorithms. Gas values are determined through extensive benchmarking and network consensus. See the [Gas Model documentation](./Gas-Model.md) for detailed cost tables.



## 5. Example Syntax: PQC-Verified DAO Contract

This section provides an example of a simplified Decentralized Autonomous Organization (DAO) contract written in SynQ, demonstrating the use of post-quantum cryptographic types and functions for secure proposal voting and execution. In this DAO, critical actions, such as executing a proposal, require a signature verified by an ML-DSA public key held by a designated 'governance' multisig or a set of trusted parties.

```synq
// Define a structure for proposals
struct Proposal {
    UInt256 id;
    Address proposer;
    Bytes  description;
    Bool   executed;
    UInt256  votesFor;
    UInt256  votesAgainst;
}

// Define the DAO contract
contract PQCVerifiedDAO {

    // State variables
    Address public owner;
    MLDSAPublicKey public governanceKey; // Public key for PQC-verified governance actions
    mapping(UInt256 => Proposal) public proposals;
    UInt256 public nextProposalId;

    // Events
    event ProposalCreated(UInt256 indexed id, Address indexed proposer);
    event Voted(UInt256 indexed proposalId, Address indexed voter, Bool support);
    event ProposalExecuted(UInt256 indexed id);

    // Constructor: Sets the contract owner and the initial governance public key
    constructor(MLDSAPublicKey _governanceKey) {
        owner = msg.sender;
        governanceKey = _governanceKey;
        nextProposalId = 1;
    }

    // Function to create a new proposal
    function createProposal(Bytes _description) public returns (UInt256) {
        UInt256 proposalId = nextProposalId;
        proposals[proposalId] = Proposal({
            id: proposalId,
            proposer: msg.sender,
            description: _description,
            executed: false,
            votesFor: 0,
            votesAgainst: 0
        });
        nextProposalId += 1;
        emit ProposalCreated(proposalId, msg.sender);
        return proposalId;
    }

    // Function to vote on a proposal
    function vote(UInt256 _proposalId, Bool _support) public {
        require(proposals[_proposalId].id != 0, "Proposal does not exist");
        // In a real DAO, more complex voting logic would be here (e.g., one vote per address, token-weighted voting)
        if (_support) {
            proposals[_proposalId].votesFor += 1;
        } else {
            proposals[_proposalId].votesAgainst += 1;
        }
        emit Voted(_proposalId, msg.sender, _support);
    }

    // Function to execute a proposal, requiring a PQC signature
    function executeProposal(
        UInt256 _proposalId,
        Bytes _messageToSign, // The message that was signed (e.g., proposalId + action details)
        MLDSASignature _signature
    ) public {
        require(proposals[_proposalId].id != 0, "Proposal does not exist");
        require(!proposals[_proposalId].executed, "Proposal already executed");

        // Verify the ML-DSA signature using the stored governance public key
        // The _messageToSign would typically include the proposal ID and the intended action
        Bool isValidSignature = verifyMLDSASignature(
            governanceKey,
            _messageToSign,
            _signature
        );

        require(isValidSignature, "Invalid PQC governance signature");

        // Example: Simple majority vote for execution
        require(proposals[_proposalId].votesFor > proposals[_proposalId].votesAgainst, "Proposal not approved by majority");

        // Mark proposal as executed and perform the action (e.g., call another contract, change state)
        proposals[_proposalId].executed = true;
        // <DAO specific action would go here>
        emit ProposalExecuted(_proposalId);
    }

    // Function to update the governance key (requires existing governance key signature)
    function updateGovernanceKey(
        MLDSAPublicKey _newGovernanceKey,
        Bytes _messageToSign,
        MLDSASignature _signature
    ) public {
        // This function itself would need to be callable only by the current governance key
        // For simplicity, we assume 'owner' can call it, but in a real PQC DAO, this would be a proposal
        // that gets executed after PQC verification.

        Bool isValidSignature = verifyMLDSASignature(
            governanceKey,
            _messageToSign,
            _signature
        );
        require(isValidSignature, "Invalid PQC signature for governance key update");

        governanceKey = _newGovernanceKey;
    }
}
```

### Explanation of PQC Elements in the DAO Contract:

*   **`MLDSAPublicKey public governanceKey;`**: A state variable to store the ML-DSA public key that is authorized to sign critical governance actions. This key would typically belong to a multi-signature wallet or a set of highly trusted individuals/entities.
*   **`constructor(MLDSAPublicKey _governanceKey)`**: The constructor initializes the DAO with the designated ML-DSA public key.
*   **`executeProposal(...)` function**: This function is central to the DAO's operation. Before a proposal can be executed, it requires a valid ML-DSA signature. The `verifyMLDSASignature` built-in function is used to check the authenticity of this signature against the `governanceKey`.
*   **`updateGovernanceKey(...)` function**: This function demonstrates how the `governanceKey` itself could be updated, again requiring a valid signature from the *current* `governanceKey` to prevent unauthorized changes. In a more robust DAO, this update would likely be part of a proposal that goes through the voting process.

This example illustrates how SynQ's native support for PQC types and verification functions enables the creation of smart contracts that are resilient to quantum attacks, particularly for critical on-chain governance mechanisms.
